################################################################################
# CC13x2/CC26x2 CPU makefile

# ccfg.c comes from the device-specific startp_files folder,
# and startup_cc13xx_cc26xx_gcc.c comes from NoRTOS startup folder
CPU_START_SOURCEFILES += ccfg.c startup_cc13xx_cc26xx_gcc.c

################################################################################
# Device Family
DEVICE_FAMILY_H := $(SIMPLELINK_SDK)/source/ti/devices/DeviceFamily.h

# The define of the Device Family ID is on the format of either
#       #define DeviceFamily_ID_<device>        <number>
# or
#       #define DeviceFamily_ID_<device>        <sub-device-family-id>
# We are interested in the right-hand side of the define, i.e. the third word on the line,
# as it either defines a number or an another Device Family ID.
DEVICE_DEFINE := $(shell cat $(DEVICE_FAMILY_H) \
    | grep "\#define DeviceFamily_ID_$(DEVICE_FAMILY)\\b" \
    | awk '{print $$3}')

# If the define is a number, then the device family name is the resulting device name;
# Else, it points to a sub-name of the device family, e.g. DeviceFamily_ID_CC13X2_V1.
# This line checks if the extracted define is a number or not, based on this SO post:
#     https://stackoverflow.com/a/19116862/5099169
# Return value 0 is no error, i.e. is a number.
IS_NUMBER := $(shell [ "$(DEVICE_DEFINE)" -eq "$(DEVICE_DEFINE)" ] 2>/dev/null; echo $$?)

ifeq ($(IS_NUMBER),0)
  # The define points to a number, meaning the device family name is the same as the
  # specified device name in lower case, e.g.
  #    cc13x2
  DEVICE_FAMILY_NAME := $(DEVICE_FAMILY_LC)
else
  # The define points to a sub-name of the device family. The resulting device family name
  # is therefore the name after specified after ID in lower case, e.g.
  #    DeviceFamily_ID_CC13X2_V1
  # will result in
  #    cc13x2_v1
  DEVICE_FAMILY_NAME := $(shell echo "$(DEVICE_DEFINE)" \
      | sed -E "s/DeviceFamily_ID_(.+)/\1/" \
      | tr A-Z a-z)
endif

# The DeviceFamily_constructPath() macro in DeviceFamily.h will always construct the
# correct path for device specific files. In this case, constructing the device specific
# root path. Note that the returned path is encased in angular brackets, <...>,
# and is therefore extracted with sed.
SDK_DEVICE_DIR := $(shell echo "DeviceFamily_constructPath(dummy)" \
    | arm-none-eabi-cpp -x c -E -DDeviceFamily_$(DEVICE_FAMILY) -include $(DEVICE_FAMILY_H) - \
    | tail -1 \
    | sed -E 's:<(.+)/dummy>:\1:')

################################################################################
# Simplelink SDK paths

SDK_KERNEL := $(SIMPLELINK_SDK)/kernel/nortos
SDK_SOURCE := $(SIMPLELINK_SDK)/source
SDK_BOARDS := $(SDK_SOURCE)/ti/boards
SDK_DRIVERS := $(SDK_SOURCE)/ti/drivers
SDK_DEVICE := $(SDK_SOURCE)/$(SDK_DEVICE_DIR)

EXTERNALDIRS += $(SDK_SOURCE)
EXTERNALDIRS += $(SDK_KERNEL)
EXTERNALDIRS += $(SDK_KERNEL)/startup
EXTERNALDIRS += $(SDK_DEVICE)
EXTERNALDIRS += $(SDK_DEVICE)/startup_files

### CPU-dependent source files
CONTIKI_CPU_SOURCEFILES += rtimer-arch.c clock-arch.c
CONTIKI_CPU_SOURCEFILES += watchdog-arch.c dbg-arch.c
CONTIKI_CPU_SOURCEFILES += uart0-arch.c slip-arch.c
CONTIKI_CPU_SOURCEFILES += batmon-sensor.c gpio-hal-arch.c
CONTIKI_CPU_SOURCEFILES += int-master-arch.c

### RF source files
CONTIKI_CPU_SOURCEFILES += rf-core.c rf-data-queue.c
CONTIKI_CPU_SOURCEFILES += ieee-addr.c ble-addr.c
CONTIKI_CPU_SOURCEFILES += rf-ble-beacond.c

ifeq ($(SUPPORTS_PROP_MODE),1)
CONTIKI_CPU_SOURCEFILES += rf-prop-mode.c prop-settings.c
endif

ifeq ($(SUPPORTS_IEEE_MODE),1)
CONTIKI_CPU_SOURCEFILES += rf-ieee-mode.c ieee-settings.c
endif

ifeq ($(SUPPORTS_BLE_BEACON),1)
CONTIKI_CPU_SOURCEFILES += ble-settings.c
endif

### CPU-dependent debug source files
MODULES += os/lib/dbg-io

### CPU-dependent directories
CONTIKI_CPU_DIRS += . dev $(SUBFAMILY)
CONTIKI_CPU_DIRS += rf-settings rf-settings/$(DEVICE_FAMILY_LC)

CONTIKI_SOURCEFILES += $(CONTIKI_CPU_SOURCEFILES) $(DEBUG_IO_SOURCEFILES)

### Linker flag
LDFLAGS += --entry resetISR
LDFLAGS += -static
LDFLAGS += --specs=nano.specs
# NB! The symbol _stack, which points to the stack start, is expected to be defined,
# but should already be defined in the linker script.
LDFLAGS += -Wl,--defsym=_stack_origin=__stack_end
LDFLAGS += -Wl,--defsym=_heap=__heap_start__
LDFLAGS += -Wl,--defsym=_eheap=__heap_end__

LDSCRIPT := $(CONTIKI_CPU)/$(SUBFAMILY)/$(SUBFAMILY).lds

### Always re-build ieee-addr.o in case the command line passes a new NODEID
FORCE:

$(OBJECTDIR)/ieee-addr.o: ieee-addr.c FORCE | $(OBJECTDIR)
	$(TRACE_CC)
	$(Q)$(CC) $(CFLAGS) -c $< -o $@

### Always re-build ccfg.c so changes to ccfg-conf.h will apply without having
### to make clean first
$(OBJECTDIR)/ccfg.o: ccfg.c FORCE | $(OBJECTDIR)
	$(TRACE_CC)
	$(Q)$(CC) $(CFLAGS) -include "ccfg-conf.h" -c $< -o $@

include $(CONTIKI_CPU)/$(SUBFAMILY)/Makefile.$(SUBFAMILY)
